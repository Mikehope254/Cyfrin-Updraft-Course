# Foundry Fundamentals

Welcome to Foundry 101. Throughout this course, you will acquire the skills you’ll need to start developing your smart contracts and protocols using the best web3 development tools and frameworks like Chainlink, Alchemy, and Foundry.

### What is Foundry?

Foundry is a relatively new but rapidly growing smart contract development framework known for its efficiency and modularity. The best short description of this powerful tool can be found in the [Foundry Book:](https://getfoundry.sh/)

```
Foundry manages your dependencies, compiles your project, runs tests, deploys, and lets you interact with the chain from the command-line and via Solidity scripts.

```

Please take a moment to bookmark the [Foundry Book:](https://getfoundry.sh/). It is the most comprehensive resource that has the answers to all your questions. It will be handy along the way.

Foundry has numerous pros, such as:

- It leverages Rust for compilation, offering significantly faster build times compared to frameworks like Hardhat or Brownie.

- It's entirely Solidity-based, eliminating the need to learn other programming languages

- Its documentation is comprehensive.

### Our favorite code editor: Visual Studio Code

Throughout this course, we will use Visual Studio Code to write, test, deploy and interact with our smart contracts. Visual Studio Code is a lightweight, powerful source code editor available on Windows, macOS and Linux. It has a comprehensive ecosystem of extensions that makes it one of the best choices when it comes to smart contract development.

# Development environment setup (Mac, Linux)
You know this

# Foundry setup

### Keeping your Terminal Clutter-free

When commands pile up in your terminal, things can get a little overwhelming. Clear it up by simply typing `clear` and hitting `Enter`. Alternatively, use `Command K` if you're on a Mac or `Control K` if you're on Linux or Windows.

Pro tip: This is one of my favorite keyboard shortcuts that I use all the time.

### Understanding the Trash Can and the X

The trash can and the X buttons in your terminal perform distinct functions. Hitting X simply hides your terminal but retains all the previous lines of code. On the other hand, trashing it essentially deletes whatever is running in it. To open up a clean terminal, hit the trash can and then pull it back using `Control+`` or `Terminal > New Terminal`.

### Installing Foundry

With our terminal set and some tips up our sleeve, let's progress to installing Foundry. Navigate to the [Foundry website](https://getfoundry.sh/introduction/installation/) and from the installation tab, fetch the command to install Foundry.

The command would look something like this:

```bash
curl -L https://foundry.paradigm.xyz | bash
```

Hit `Enter` after pasting this in your terminal.

Note: You must have Internet access for this to work as it's downloading Foundry from their official website.

### Verifying Your Installation
After running the `curl` command, an output will appear at the bottom of your terminal indicating the detected shell and the fact that Foundry has been added to your Path.

For instance, the output can be something like this:

```bash
Detected your preferred shell is bashrc and added Foundry to Path run:source /home/user/.bashrcStart
a new terminal session to use Foundry
```

Now, simply type `foundryup` and `Enter` to install and update Foundry to the latest version. Whenever you want to install an update for Foundry, simply run `foundryup` again.

This will install four components: forge, cast, anvil, and chisel. To confirm the successful installation, run `forge --version`. You should get an output indicating the Forge version as shown below.

```bash
Forge version x.x.x
```

### Is Foundry Up Not Running?
Don't panic if this command doesn't run. You might have an issue with your path, and you might need to add Foundry to your path. In case you run into this issue, check lesson 6 of the GitHub repo associated with this course. If no debugging tips are available there, feel free to start a discussion on the course's GitHub repo. Before doing so, make sure to check if a similar discussion already exists.

Try typing `forge --version` into your terminal. Have you received an unwelcome output saying `Forge command found?` This implies that you have to rerun the `source` command that Foundry offered during installation.

Note: Most of the time the `bashrc` file gets loaded automatically. However, if this doesn't apply to your setup, the following lines can add the required command to the end of your `Bash profile`. This will ensure that your `bashrc` file loads by default.

```bash
cd ~
echo 'source /home/user/.bashrc' >> ~/.bash_profile
```

> this depends on your operating system, please check foundry docs to see detailed instructions.

# Quiz 7

**1. What is the main purpose of using a version control system like Git in your projects?**
* *a) To automatically fix bugs in the codebase.*
* *b) To optimize the performance of the final application.*
* *c) To design the visual layout of a user interface*
* *d) To track and manage changes to files, especially source code, over time.*

<details>
  <summary>Click to reveal answer</summary>
  <p>d) To track and manage changes to files, especially source code, over time.</p>
</details>

**2. When setting up credentials in some command-line interfaces, typed passwords may not be visually displayed. What is the typical reason for this behavior?**
* *a) It shows that the password has been automatically generated by the system.*
* *b) It indicates that the system does not actually require a password.*
* *c) It's a security measure to prevent ('shoulder surfing') from seeing the password as it's typed.*
* *d) It means the keyboard has temporarily stopped working correctly.*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) It's a security measure to prevent ('shoulder surfing') from seeing the password as it's typed.</p>
</details>

**3. When working within a third-party cloud development platform, what practice is crucial regarding sensitive credentials?**
* *a) Assume the environment is as secure as your local machine for all data.*
* *b) Use only test or non-production credentials with no real-world value.*
* *c) Store credentials directly within the source code for easy access.*
* *d) Share credentials with team members via the platform's chat feature.*

<details>
  <summary>Click to reveal answer</summary>
  <p>b) Use only test or non-production credentials with no real-world value.</p>
</details>

**4. Which of the following represents a key advantage of utilizing a cloud-based development environment?**
* *a) Complete independence from internet connectivity.*
* *b) Guaranteed lower cost compared to local development.*
* *c) Reduced setup time and standardized environment configuration.*
* *d) Enhanced security for handling production secrets.*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) Reduced setup time and standardized environment configuration.</p>
</details>

**5. If a terminal interface is hidden from view but the session itself is not terminated, what typically happens to processes running within that session?**
* *a) The processes continue to run in the background.*
* *b) The processes are automatically paused until the interface is visible again.*
* *c) The processes are transferred to a new, visible terminal session.*
* *d) The processes are immediately stopped.*

<details>
  <summary>Click to reveal answer</summary>
  <p>a) The processes continue to run in the background.</p>
</details>

**6. In the context of blockchain development toolkits, what function does a component often referred to as a 'local node simulator' (like Anvil, Ganache, or Hardhat Network) typically serve?**
* *a) It manages the secure storage of private keys for deploying contracts.*
* *b) It provides an isolated, high-speed local blockchain environment for development, testing, and debugging of smart contracts.*
* *c) It serves as a code editor specifically designed for writing smart contract languages.*
* *d) It acts as a primary interface for sending transactions to the main public blockchain.*

<details>
  <summary>Click to reveal answer</summary>
  <p>b) It provides an isolated, high-speed local blockchain environment for development, testing, and debugging of smart contracts.</p>
</details>

**7. After installing a new command-line utility, what is a common way to verify that the installation was successful and the tool is accessible system-wide?**
* *a) Executing the command name followed by a flag to request its version information (e.g., `toolname --version`).*
* *b) Manually searching the file system for the tool's primary executable file.*
* *c) Checking the system's control panel for a new entry in installed applications.*
* *d) Rebooting the operating system and checking system logs.*

<details>
  <summary>Click to reveal answer</summary>
  <p>a) Executing the command name followed by a flag to request its version information (e.g., `toolname --version`).</p>
</details>

# Create a new Foundry Project
Reminder: We ran the following commands

```bash
mkdir foundry-f23
cd foundry-f23
```

Now type the following commands:

```bash
mkdir foundry-simple-storage-f23
cd foundry-simple-storage-f23
```

You can always make the cd command faster by pressing the Tab key after you type the first couple of letters from the destination name. Tab lets you autocomplete a lot of commands/paths.

If you type `code .` a new instance of VS Code will open, having the foundry-simple-storage-f23 as the default path.

You can see the contents of this folder on the left sidebar. Try the following command:

```bash
touch randomFile.txt
```

This will create a randomFile.txt

If you want to delete it type:

```bash
rm randomFile.txt
```

The terminal is pretty slick when it comes to moving/opening/creating directories/files, changing paths and generally running things. I recommend going through [this tutorial](https://ubuntu.com/tutorials/command-line-for-beginners#1-overview) if you want to learn how to move extra fast.

### Creating a New Project
The way you [create a new Foundry project](https://getfoundry.sh/guides/project-setup/creating-a-new-project/) is by running the `forge init` command. This will create a new Foundry project in your current working directory.

If you want Foundry to create the new project in a new folder type `forge init nameOfNewFolder`.

Keep in mind that by default `forge init` expects an empty folder. If your folder is not empty you must run `forge init --force`.

Be sure to configure your username and email if you encounter errors related to Git configuration.

```bash
git config --global user.email "yourEmail@provider.com"
git config --global user.name "yourUsername"
```

And that's it, your folder should look as follows:

![Foundry1](../Images/foundry1.png)

But what does all this mean?

`lib` is the folder where all your dependencies are installed, here you'll find things like:

- `forge-std` (the forge library used for testing and scripting)

- `openzeppelin-contracts` is the most battle-tested library of smart contracts

- and many more, depending on what you need/install

`scripts` is a folder that houses all your scripts

`src` is the folder where you put all your smart contracts

`test` is the folder that houses all your tests

`foundry.toml` - gives configuration parameters for Foundry

More on these folders and files later.

Please right-click `src`, click on `New File` and name it `SimpleStorage.sol`. Copy the code available [here](https://github.com/Cyfrin/foundry-simple-storage-cu/blob/main/src/SimpleStorage.sol).

One last thing, please delete `Counter.s.sol`, `Counter.sol` and `Counter.t.sol`. These files are a set of basic smart contracts that Foundry provides as a default when you create a new Foundry project.

# Foundry Setup (Windows/WSL)

### WSL setup
Microsoft has significantly improved its development environment support in recent years. However, for _smart contract development_, installing dependencies can sometimes be tricky. To streamline this process, we will use the Windows Subsystem for Linux (WSL): this is a better option because it enables a full-fledged unix-like console on your Windows machine, simplifying the use of tools and utilities commonly found in _unix-based environments_. This setup ensures compatibility with all the code that runs on unix-based systems like macOS and Linux.

To install WSL, you can begin by opening the Windows terminal. On Windows 11, press the Windows key, type "terminal," and hit enter. On Windows 10, you need to install the Windows terminal from the Microsoft Store (select the official app from Microsoft Corporation).

Once installed, open the terminal and type `wsl --install`. This command will initiate the installation process. Afterward, restart your computer. Upon reboot, the terminal will appear again, prompting you to select a Unix username and set a password. WSL will be then successfully installed ✅.

Visual Studio Code
After installing WSL, we need to install a code editor. We will use Visual Studio Code (VS Code), and there are three different methods to install it:

1. Using the Terminal: Utilize `winget`, a package manager pre-installed on Windows 11. Open the terminal and type winget search VS Code to find the desired package. Then, execute `winget install Microsoft.VisualStudioCode` to install VS Code.

2. Via Web Browser: Search for "Visual Studio Code" in your web browser, select the official Microsoft link and download the installer. Follow the prompts, accept the user agreement and customize all the installation options.

3. Using VSCodium: For those who prefer more independence and privacy, there is an open-source alternative called VSCodium. It is similar to VS Code but without Microsoft's telemetry. Download the [VSCodium installer](https://github.com/VSCodium/vscodium/releases) from GitHub and follow its similar installation steps.

Choose the method that best suits your needs. For this course, I will use the official Visual Studio Code from Microsoft.

# VSCode Solidity setup

### Improving Code Format in Visual Studio Code
When you first start, your code might just look like a whole bunch of dull, lifeless, white text.

This can be easily fixed by using one of the `Solidity` extensions. Out of all the Solidity extensions available in the Extensions tab (CTRL/CMD + SHIFT + X) the following are worth mentioning:

1. Solidity by Juan Blanco, the most used Solidity extension out there.

2. Solidity by Nomic Foundation is Patrick's favorite Solidity extension. The rest of the course will be displaying this extension.

3. Solidity Visual Developer is another popular choice.

NOTE: If the code remains unhighlighted despite having installed the extension, there's a quick solution to that. `Press Command + Shift + P` or `Control + Shift + P` on Windows. This opens up the command bar. In the command bar, type in "Settings" and select "Preferences: Open User Settings (JSON)".

If you have nothing in there, create a new setting by typing in:

```solidity
{
  "editor.defaultFormatter": "NomicFoundation.hardhat"
}
```

Use:

`"editor.defaultFormatter": "tintinweb.solidity-visual-auditor"` for Solidity Visual Developer

or

`"editor.defaultFormatter": "JuanBlanco.solidity"` for Solidity by Juan Blanco

### Other interesting extensions
In the previous lesson, we mentioned a file called `foundry.toml`. This also has an extension that formats it to make it easier to read. Please install [Even Better TOML](https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml).

Another indispensable extension is [Inline Bookmarks](https://marketplace.visualstudio.com/items?itemName=tintinweb.vscode-inline-bookmarks).

The Inline Bookmarks plugin facilitates bookmarking the actual code. The extension can be used for document review, auditing, log analysis, and keeping track of development notes and to-do lists. You may share your notes and bookmarks with others with ease because they are saved with your files.

The following default trigger words/tags are configured by default:

```solidity
@todo - (blue) General ToDo remark.
@note - (blue) General remark.
@remind - (blue) General remark.
@follow-up - (blue) General remark.
@audit - (red) General bookmark for potential issues.
@audit-info - (blue) General bookmark for information to be noted for later use.
@audit-ok - (green) Add a note that a specific line is not an issue even though it might look like.
@audit-issue - (purple) Reference a code location an issue was filed for.
```

You can fully customize the colors!

Remember these! They will be very handy in developing and especially in auditing projects.

More details are available [here](https://github.com/tintinweb/vscode-inline-bookmarks).

Next comes the fun part! Let's compile our contract using Foundry!

# Compile a smart contract using Foundry

Open a new terminal. Type in `forge build` or `forge compile` to compile the smart contracts in your project.

Once the compiling is finished, you'll see some new folders in the Explorer tab on the left side. One of them is a folder called out. Here you'll be able to find the [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html) of the smart contract together with the [Bytecode](https://www.geeksforgeeks.org/solidity/introduction-to-bytecode-and-opcode-in-solidity/) and a lot of useful information.

The cache folder also appears. Generally, this folder is used to store temporary system files facilitating the compilation process. But for this course, you can safely ignore it.

### More terminal wizardry
Throughout your solidity development/audit journey you will type a lot of terminal commands, every time to make a change that you want tested you'll probably have to rerun the `forge build` then maybe you test it with `forge test` or run a script with `forge script` and many more. Typing all these over and over again is inefficient and time-consuming. The better way is to use the `up` and `down` arrow keys. The up and down arrow keys to cycle through the recent commands.

Ok, cool! We learned how to compile a contract, but how does one deploy a smart contract?

# Quiz 13

**1. When editing text files within a VS Code, how is the status of unsaved modifications commonly indicated?**
* *a) The background color of the editor changes intensity.*
* *b) An audible alert sounds periodically.*
* *c) A dot appears next to the filename.*
* *d) The file automatically closes after a period of inactivity.*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) A dot appears next to the filename.</p>
</details>

**2. What role does a configuration file (e.g., `foundry.toml`, `package.json`) typically play within a software development project?**
* *a) It contains the main executable code of the application.*
* *b) It defines project-specific settings, dependencies, and parameters for the development tools and build process.*
* *c) It primarily serves as documentation for end-users.*
* *d) It stores large binary assets used by the project.*

<details>
  <summary>Click to reveal answer</summary>
  <p>b) It defines project-specific settings, dependencies, and parameters for the development tools and build process.</p>
</details>

**3. Compared to using HTTPS authentication (requiring username/password or tokens), what is a primary advantage of using SSH keys for interacting with remote Git repositories?**
* *a) Automatically compresses repository data more effectively.*
* *b) Often eliminates the need to repeatedly enter credentials for operations like pushing code after initial setup.*
* *c) Enables collaboration features not available with HTTPS.*
* *d) Provides significantly faster data transfer speeds for cloning.*

<details>
  <summary>Click to reveal answer</summary>
  <p>b) Often eliminates the need to repeatedly enter credentials for operations like pushing code after initial setup.</p>
</details>

**4. Applying consistent indentation and spacing rules throughout a codebase primarily helps to:**
* *a) Optimize the code for faster performance.*
* *b) Reduce the number of lines of code required.*
* *c) Guarantee the code is free of runtime errors.*
* *d) Enhance code maintainability and readability for developers.*

<details>
  <summary>Click to reveal answer</summary>
  <p>d) Enhance code maintainability and readability for developers.</p>
</details>

**5. Which component generated during compilation represents the actual code that is stored on the blockchain after the contract deployment process is complete?**
* *a) Initial Bytecode*
* *b) Function Selectors*
* *c) Deployed Bytecode*
* *d) Abstract Syntax Tree (AST)*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) Deployed Bytecode</p>
</details>

**6. When a smart contract is compiled, what standard interface specification is generated to define how applications can interact with it?**
* *a) Contract Deployment Manifest (CDM)*
* *b) Application Programming Interface (API)*
* *c) Application Binary Interface (ABI)*
* *d) Source Code Map (SCM)*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) Application Binary Interface (ABI)</p>
</details>

**7. Compilation tools often generate output files containing contract details. Where are these essential output files, such as the ABI and bytecode, stored within a project structure?**
* *a) In a dedicated output or build artifacts directory.*
* *b) In a temporary system-wide cache folder.*
* *c) Alongside the testing scripts in the project scripts polder.*
* *d) Directly within the main source code directory.*

<details>
  <summary>Click to reveal answer</summary>
  <p>a) In a dedicated output or build artifacts directory.</p>
</details>

**8. What information does the 'bytecode' component of a compilation output primarily contain?**
* *a) A human-readable description of the contract's functions.*
* *b) The low-level instructions executed by the blockchain's virtual machine.*
* *c) Mappings between function names and their memory addresses.*
* *d) Metadata about the compiler version and license.*

<details>
  <summary>Click to reveal answer</summary>
  <p>b) The low-level instructions executed by the blockchain's virtual machine.</p>
</details>

# Deploying a smart contract Locally using Anvil

There are multiple ways and multiple places where you could deploy a smart contract.

While developing using the Foundry framework the easiest and most readily available place for deployment is Anvil.

Anvil is a local testnet node shipped with Foundry. You can use it for testing your contracts from frontends or for interacting over RPC.

To run Anvil you simply have to type `anvil` in the terminal.

![anvil](../Images/anvil.png)

You now have access to 10 test addresses funded with 10_000 ETH each, with their associated private keys.

This testnet node always listens on `127.0.0.1:8545` this will be our `RPC_URL` parameter when we deploy smart contracts here. More on this later!

More info about Anvil is available [here](https://getfoundry.sh/anvil/overview#anvil).

Please press `Ctrl/CMD + C` to close Anvil.

Anvil will be used throughout the course to deploy and test our smart contracts, but before that, let's quickly check an intermediary step.

## Configuring MetaMask

To deploy to a custom network (like your localhost), you'll need MetaMask. MetaMask is a popular cryptocurrency wallet and browser extension that allows users to interact with the Ethereum blockchain and its ecosystem.

Follow these steps:

   1. Open MetaMask.

   2. Click the three little dots and select 'Expand View'.

   3. Go to 'Settings', then 'Networks'.

   4. Here, you'll see the list of networks (Ethereum, Mainnet, etc.) with plenty of details about each one. Locate the RPC URL - this is key.

The RPC URL is essentially the endpoint we make API calls to when sending transactions. For every blockchain transaction you execute, you're making an API to whatever is in here.
To send a transaction to your custom blockchain, you need to add it as a network:

   1. Click on 'Add a Network'

   2. Scroll to the bottom of the list of networks.

   3. Hit 'Add a Network manually'.

   4. Enter the details of your local network

   - Network name: Localhost

   - New RPC URL: Ganachehttp://127.0.0.1:7545 or Anvil http://127.0.0.1:8545 (make sure you always add http://) - these two could differ on your machine, please consult the Ganache UI or Anvil terminal for the exact RPC URL.

   - Chain ID: Ganache 5777(sometimes 1337) or Anvil 31337 - these two could differ on your machine, please consult the Ganache UI or Anvil terminal for the exact Chain ID.

   - Currency symbol: ETH

   - Block explorer URL: - (we don't have a block explorer for our newly created blockchain, which will most likely disappear when we close the VS Code / Ganache app)

Great! Now that we configured our local network, the next step is to add one of the accounts available in Ganache or Anvil into our MetaMask. This is done as follows:

   1. Click the account selector at the top of your wallet.

   2. Click Add account or hardware wallet.

   3. Click Import account

   4. You will be directed to the Import page. Paste your Ganache/Anvil private key. Click Import.

**NOTE: Do not use this account for anything else, do not interact with it or send things to it on mainnet or any other real blockchain, use it locally, for testing purposes. Everyone has access to it.**

Next up we shall talk more about adding a new network to MetaMask.

## Adding New Networks Using MetaMask

Conveniently, MetaMask provides an easy way to add EVM-compatible chains. By pre-configuring a host of them, you can add a chain such as the Arbitrum One by simply clicking on the `Networks` button on the top left, then `Add Network` and proceeding to `Add`. The pleasing part is that MetaMask does all the grunt work, filling in all the necessary information for you. A click on Approve Network ensures the successful addition of the network.

Steps:

   1. Click on the Networks button on the top left

   2. Click on Add Network

   3. Choose your desired EVM-compatible chain

   4. Click on Add

   5. After ensuring all necessary information is already filled in, click on Approve Network

But what can you do if the chain you want to add is not pre-configured?

Simple! You employ the same process we just used to add our new Anvil local chain in the previous lesson

# Deploy a smart contract locally using forge

To find out more about forge's capabilities type

```solidity
forge --help
```

Out of the resulting list, we are going to use the `create` command.

Type `forge create --help` in the terminal or go [here](https://getfoundry.sh/forge/reference/forge-create/) to find out more about the available configuration options.

Try running `forge create SimpleStorage`. It should fail because we haven't specified a couple of required parameters:

   1. `Where do we deploy?`

   2. `Who's paying the gas fees/signing the transaction?`

Let's tackle both these questions.

As you've learned in the previous lessons, each blockchain (private or public) has an RPC URL (RPC SERVER) that acts as an endpoint. When we tried to deploy our smart contract, forge tried to use `http://localhost:8545/`, which doesn't host any blockchain. Thus, let's try to deploy our smart contract specifying the place where we want to deploy it.

Please start Ganache and press Quickstart Ethereum. Copy the RPC Server HTTP://127.0.0.1:7545. Let's run our forge create again specifying the correct rpc url.

```solidity
forge create SimpleStorage --rpc-url http://127.0.0.1:7545
```

This again failed, indicating the following:
```
Error accessing local wallet. Did you set a private key, mnemonic or keystore?
```

Try the following command:

```
forge create SimpleStorage --rpc-url http://127.0.0.1:7545 --interactive
```
You will be asked to enter a private key, please paste one of the private keys available in Anvil. When you paste a key you won't see the text or any placeholder symbols, just press CTRL(CMD) + V and then ENTER.

> for **clearer** output try:

> ```
> forge create SimpleStorage --rpc-url http://127.0.0.1:7545 --interactive --broadcast
> ```

Voila!

![forge-create](../Images/forge-create.png)

From now on, everything we deploy shall be done on Anvil. But if you like Ganache more, feel free to use that.

Do the following:

   1. Run `clear`

   2. Run `anvil`

   3. Create a new terminal by pressing the + button

   4. Copy one of the private keys from the anvil terminal

   5. Run forge create SimpleStorage --interactive --broadcast
    We don't need to specify an --rpc-url this time because forge defaults to Anvil's RPC URL.

   6. Go to the Anvil terminal and check the deployment details:

```solidity
    Transaction: 0x40d2ca8f0d680f098c7d5e3c127ef1ce1207ef439ba6e163c2042483e15998a6
    Contract created: 0x5fbdb2315678afecb367f032d93f642f64180aa3
    Gas used: 357076
​
    Block Number: 1
    Block Hash: 0x85a56c0b8f166e86d1cce65412615e0d9a72972e04b2488023275131ea27330a
    Block Time: "Mon, 15 Apr 2024 11:50:55 +0000"
​```

The more explicit way to deploy using forge create is as follows:

``` solidity
forge create SimpleStorage --rpc-url http://127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 --broadcast
```

We included the --rpc-url to not count on the default and the --private-key to not use the --interactive option anymore.

>> --broadcast option displays output more clearly compared in later forge versions

Pfew! That was a lot, but we learned a very important thing, how to deploy a smart contract on two local blockchains. But what comes next is one of the most important if not the MOST IMPORTANT aspects you will learn here: _Private key safety_.

***

# Practicing Private Key Safety

Having a private key in plain text is extremely bad. The private key(s) we used in the last lesson are well-known keys for local testing, you shouldn't use those on mainnet and keeping them in plain text is ok, but any other private key should be kept hidden, especially your production key or key's associated with accounts that hold crypto.

Moreover, it's very bad to have private keys in bash history (hit the up arrow and see the key you used to deploy).

You can delete your history by typing:

```bash
history -c
```

We will teach you more about how to secure private keys in one of the next lessons.

## Your Safety Promise

It's time now to articulate your promise for maintaining private key safety. Create a file titled Promise.md. In this file, make it a point to write down your promise:

```markdown
I promise to never use my private key associated with real money in plain text.
```

If you feel comfortable doing so, consider tweeting this to affirm and secure your pledge. Make sure to tag @PatrickAlphaC and @CyfrinUpdraft or any other professional in this field to hold yourself accountable.

Hacking private keys is one of the most important reasons people and projects lose absurd amounts. You don't even need to look that deep to find titles like this:

[The Ronin hack](https://www.halborn.com/blog/post/explained-the-ronin-hack-march-2022) - Social engineering of private keys

[Early Crypto Investor Bo Shen Says He Lost $42 Million in Wallet Hack](https://www.bnnbloomberg.ca/early-crypto-investor-bo-shen-says-he-lost-42-million-in-wallet-hack-1.1850446)

[The $477 million FTX hack](https://www.elliptic.co/blog/the-477-million-ftx-hack-following-the-blockchain-trail) where `The new CEO of FTX revealed that private keys allowing access to the firm’s crypto assets were stored in unencrypted form, and a former employee disclosed that over $150 million was stolen from Alameda Research, due to poor security.`

Don't be like that! Maybe you are not holding millions, but what you hold is yours, don't let it become theirs!

In the following lessons, we'll learn how to access RPC URLs for free using Alchemy for any blockchain. We will also delve into exploring safer methodologies for dealing with private keys. Stay tuned!


# Deploy a smart contract locally using Anvil via scripts

Deploying a smart contract via scripting is particularly handy because it provides a consistent and repeatable way to deploy reliably and its features enhance the testing of both the deployment processes and the code itself.

There's a strong chance that you like the command-line approach, but scripting enriches the whole deployment process, bringing in more functionality and an ease of use second to none.

Foundry eases the whole process since it is written in Solidity. This means our deployment scripts will also be written in Solidity. It is essential to distinguish Solidity as a contract language from Solidity as a scripting language. Foundry also incorporates elements that enhance our Solidity experience beyond the smart contracts realm. So, let's get started on creating a script to deploy our simple storage contract.

In Foundry we keep our scripts in the script folder.

Please create a new file called `DeploySimpleStorage.s.sol`.

Using `.s.sol` as a suffix is a naming convention for Foundry scripts, in future lessons, when we'll write Foundry tests, these will bear the suffix of `.t.sol`.

For more best practice info regarding Foundry scripts please click [here](https://getfoundry.sh/guides/best-practices/writing-contracts/#scripts).

Open the newly created file. Here we'll write a solidity script for deploying our SimpleStorage contract.

Type the following:

```solidity
// SPDX-License-Identifier: MIT
​
pragma solidity 0.8.19;
​
contract DeploySimpleStorage {
    
}
```

The first two lines are pretty self-explanatory.

We declare the new contract, named `DeploySimpleStorage`

For it to be considered a Foundry script and to be able to access the extended functionality Foundry is bringing to the table we need to import Script from `"forge-std/Script.sol"` and make `DeploySimpleStorage` inherit Script.

NOTE: `forge-std` also called Forge Standard Library is a collection of pre-written Solidity contracts designed to simplify and enhance scripting and testing within the Foundry development framework.

Furthermore, to be able to deploy `SimpleStorage` we also need to import it by typing `import {SimpleStorage} from "../src/SimpleStorage.sol";`

```solidity
// SPDX-License-Identifier: MIT
​
pragma solidity 0.8.19;
​
import {Script} from "forge-std/Script.sol";
import {SimpleStorage} from "../src/SimpleStorage.sol";
​
contract DeploySimpleStorage is Script {
    
}
```

Every script needs a main function, which, according to the best practice linked above is called `run`. Whenever you run `forge script` this is the function that gets called.

```solidity
// SPDX-License-Identifier: MIT
​
pragma solidity 0.8.19;
​
import {Script} from "forge-std/Script.sol";
import {SimpleStorage} from "../src/SimpleStorage.sol";
​
contract DeploySimpleStorage is Script {
    function run() external returns (SimpleStorage) {
        vm.startBroadcast();
​
        SimpleStorage simpleStorage = new SimpleStorage();
​
        vm.stopBroadcast();
        return simpleStorage;
    }
}
```

`run` is an external function that will return the `SimpleStorage` contract.

In the Run function, we are going to use a distinctive keyword: `vm`. Foundry has a distinctive feature known as cheat codes. The `vm` keyword is a cheat code in Foundry, and thereby only works in Foundry.

`vm.startBroadcast` indicates the starting point for the list of transactions that get to be sent to the RPC URL;

Similarly, `vm.stopBroadcast` indicates the ending point of the list of transactions that get to be sent to the `RPC URL;`

Between those two we write:

`SimpleStorage simpleStorage = new SimpleStorage();`

The `new` keyword is used to create a new smart contract in Solidity.

We end the function with `return simpleStorage;`.

Please select the `Anvil` terminal and press `CTRL(CMD) + C` to stop it. Now run the following command:

```bash
forge script script/DeploySimpleStorage.s.sol
```

This should go through without any errors, but if you hit some errors related to `incompatible solidity versions in various files` please ensure that both the `SimpleStorage.sol` and `DeploySimpleStorage.s.sol` use `pragma solidity 0.8.19;`

If you want to further extend your knowledge about scripting please go [here](https://getfoundry.sh/guides/scripting-with-solidity/)

You should get the following output:

```solidity
[⠆] Compiling...
[⠔] Compiling 2 files with 0.8.19
[⠒] Solc 0.8.19 finished in 1.08s
Compiler run successful!
Script ran successfully.
Gas used: 338569
​
== Return ==
0: contract SimpleStorage 0x90193C961A926261B756D1E5bb255e67ff9498A1
​
If you wish to simulate on-chain transactions pass a RPC URL.
```

**The million-dollar question**: If we didn't pass an RPC URL, where did this deploy to?

If the RPC URL is not specified, Foundry automatically launches an Anvil instance, runs your script (in our case deployed the contract) and then terminates the Anvil instance.

Run the `anvil` command in the terminal, open up a new terminal and type the following:

```bash
forge script script/DeploySimpleStorage.s.sol --rpc-url http://127.0.0.1:8545
```

To get the following output:

```text
No files changed, compilation skipped
EIP-3855 is not supported in one or more of the RPCs used.
Unsupported Chain IDs: 31337.
Contracts deployed with a Solidity version equal or higher than 0.8.20 might not work properly.
For more information, please see https://eips.ethereum.org/EIPS/eip-3855
Script ran successfully.
​
== Return ==
0: contract SimpleStorage 0x34A1D3fff3958843C43aD80F30b94c510645C316
​
## Setting up 1 EVM.
​
==========================
​
Chain 31337
​
Estimated gas price: 2 gwei
​
Estimated total gas used for script: 464097
​
Estimated amount required: 0.000928194 ETH
​
==========================
​
SIMULATION COMPLETE. To broadcast these transactions, add --broadcast and wallet configuration(s) to the previous
command. See forge script --help for more.
```

**Another million-dollar question**: Is it deployed now?

Answer: No, the output indicates this was a simulation. But, we got a new folder out of this, the `broadcast` folder contains information about different script runs in case we forget details.

Hit the up arrow key and add `--interactive --broadcast --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80` at the end.

Our contract is now successfully deployed! Fantastic!

Switch to the `anvil` terminal where you'll see:

```text
    Transaction: 0x73eb9fb4ef7b159e03c50d669c42e2ec4eeaa9358bea0a710cb07168e5192570
    Contract created: 0x5fbdb2315678afecb367f032d93f642f64180aa3
    Gas used: 357088
​
    Block Number: 1
    Block Hash: 0x8ea564f146e04bb36fc27f0b491223a023b5882d2fcfce3ff85e0dd152e611e4
    Block Time: "Tue, 16 Apr 2024 13:39:51 +0000"
```

Awesome!

Through this lesson we kept talking about a thing called `transaction`, but what is a `transaction`? Tune in the next lesson to find out.

# What is a Transaction?

## More about blockchain transactions

In the previous lesson we kept talking about transactions, but we never explained what a transaction is. In simple terms, a transaction captures details of an activity that has taken place on a blockchain.

On the left side of your screen, in the Explorer tab, you'll find a folder called `broadcast`. Foundry saves all your blockchain interactions here. The `dry-run` folder is used for interactions you made when you didn't have a blockchain running (remember that time when we deployed our contract without specifying an `--rpc-url`). Moreover, the recordings here are separated by chainId.

Note: The `chainId` is a unique identifier assigned to a specific blockchain network. It is used to distinguish one blockchain from another and is a crucial parameter for ensuring the security and integrity of transactions and interactions on the blockchain.

Click on `run-latest.json`.
Here we can find more details about the last deployment script we ran in our previous lesson. It will show things like `transactionType`, `contractName` and `contractAddress`. Moreover, in the `transaction` section, you can see what we actually sent over to the RPC URL:

```javascript
      "transaction": {
        "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
        "to": null,
        "gas": "0x714e1",
        "value": "0x0",
        "input": "0x608060...c63430008130033",
        "nonce": "0x0",
        "chainId": "0x7a69",
        "accessList": null,
        "type": null
      }
```

Let's go through each of these:

   - `from` is self-explanatory, it's the address we used to sign the transaction;

   - `to` is the recipient, in our case is null or address(0), this is the standard destination for when new smart contracts are deployed;

   - `gas` is the amount of gas spent. You will see the hex value `0x714e1` (or any other value represented in hex format);

**Quick tip**: Normal humans can't understand hex values like the one indicated above, but there's a quick way to convert these into usual numbers. Run the following command in your terminal: `cast --to-base 0x714e1 dec`. `cast` is a very versatile tool provided by Foundry, type `cast --help` in your terminal to find out more, or go [here](https://getfoundry.sh/releases#cast-features).

   - `value` is the transaction value, or the amount of ETH we are sending over. Given that this transaction was made to deploy a contract, the value here is 0x0 or 0, but we could have specified a value and that would have been the initial balance of the newly deployed contract;

   - `data` in this case is the contract deployment code and the contract code. In the excerpt above this was truncated;

   - `nonce` is a unique identifier assigned to each transaction sent from a specific account. The `nonce` is used to ensure that each transaction is processed only once and to prevent replay attacks. nonce is incremented with every single transaction;

   - `accessList` is a feature of Ethereum to optimize the gas cost of transactions. It contains a list of addresses and associated storage keys that the transaction is likely to access, allowing the EVM to more efficiently compute the gas cost of storage access during the transaction's execution;

   - `type` please ignore this for now.

There are other values that play an important part that weren't presented in that list, namely the `v`, `r`, and `s`. These are components of a transaction's signature, which are used to validate the authenticity and integrity of the transaction.

Whenever we send a transaction over the blockchain there's a signature happening, that's where we use our `private key`.

Important: Every time you change the state of the blockchain you do it using a transaction. The thing that indicates the change is the data field of a transaction. Deployment bytecode, contract bytecode and OPCODEs will be tackled in a future lesson.

# Important Private Key Safety pt.2

## How to not have your private key in the command line

Some lessons ago we deployed SimpleStorage using the following command:

```solidity
forge script script/DeploySimpleStorage.s.sol --rpc-url http://127.0.0.1:8545 --broadcast --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
```

Having our private key in plain text is very bad, as we've explained in [Lesson 13](https://updraft.cyfrin.io/courses/foundry/foundry-simple-storage/private-key-safety). What can we do to avoid this, except using the `--interactive` parameter, because we don't want to keep copy-pasting our private key?

**BIG BOLDED DISCLAIMER: What we are about to do is fine for development purposes, do not put a real key here, it very terrible for production purposes.**

Create a new file in the root of your project called `.env`. Then, go the `.gitignore` file and make sure `.env` is in there.

The `.env` file will host environment variables. Variables that are of a sensitive nature that we don't want to expose in public.

Open the file and put the following in it:

```solidity
PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
RPC_URL=http://127.0.0.1:8545
```

Next run `source .env`. This adds the above-mentioned environment variables into our shell. Now run `echo $PRIVATE_KEY` or `echo $RPC_URL` to check if the values are stored in the shell.

Now we can safely replace the parameters in our `forge script` command:

```solidity
forge script script/DeploySimpleStorage.s.sol --rpc-url $RPC_URL --broadcast --private-key $PRIVATE_KEY
```

This doesn't only hide your private key from plain sight in the command line but also facilitates faster terminal usage, imagine you'd have to copy-paste the `http://127.0.0.1:8545` RPC URL over and over again. It's cleaner this way.

But yes, now we have the private key in plain text in the `.env` file, that's not good.

## How to handle this problem with production code?

Foundry has a very nice option called `keystore`. To read more about it type `forge script --help` in your terminal. Using `forge script --keystore <PATH>` allows you to specify a path to an encrypted store file, encrypted by a password. Thus your private key would never be available in plain text.

Let's agree to the following:

  - For testing purposes use a `$PRIVATE_KEY` in an `.env` file as long as you don't expose that `.env` file anywhere.

  - Where real money is involved use the `--interactive` option or a [keystore file protected by a password](https://github.com/Cyfrin/foundry-full-course-cu?tab=readme-ov-file#foundry-fundamentals-section-1-foundry-simple-storage).

There's one more thing about storing keys in a `.env` file. Please take a look at the ["THE .ENV PLEDGE"](https://github.com/Cyfrin/foundry-full-course-cu/discussions/5). Read it, understand it and comment `I WILL BE SAFE`. Tweet it, Tiktok it, blog about it, make an Insta story about it, print it and put it on your fridge and share some copies with your neighbors. Please stay safe!

# Never use a .env file

Meanwhile, some things have changed

In our previous lesson, we showed you how to configure and use a `.env` file to hold your private key and rpc url, some developments have taken place since that lesson was made so ... You should never use a `.env` again.

## Encrypting your Keys Using ERC2335

For now, let's pretend our private key is this:

0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 (key 0 from Anvil)

Type the following command in your terminal:

```solidity
cast wallet import nameOfAccountGoesHere --interactive
```

Ideally, you don't do this in your VS Code.

You will be asked for your private key and a password to secure it. You will do this only once, which is amazing!

If you remember, last lesson we deployed running the following command:

```solidity
forge script script/DeploySimpleStorage.s.sol --rpc-url $RPC_URL --broadcast --private-key $PRIVATE_KEY
```

Now that we configured our wallet we can deploy as following:

```solidity
forge script script/DeploySimpleStorage.s.sol --rpc-url http://127.0.0.1:8545 --broadcast --account nameOfAccountGoesHere --sender 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
```

You will be asked for your password. You won't be able to deploy without your password.

To see all the configured wallets you can call the following: cast wallet list.

Clear your history so your private key won't randomly remain there using the following command: history -c.

Stay safe! Stay froggy! Don't lose your keys. If you are seeing your private key in plain text, you are doing something wrong.

# Interact with a smart contract using the CLI

## Interacting With Contract Addresses via Command Line & Foundry's Cast Tool

This lesson builds on top of previous lessons where we deployed `SimpleStorage` via `forge script`. We have `Anvil` running and the smart contract is deployed.

Copy the contract address.

## Sending information to the blockchain

Foundry has a built-in tool known as `Cast`. `Cast` comes loaded with numerous commands to interact with. Learn more about them by typing `cast --help`. One such useful command is `send` which is designed to sign and publish a transaction. To view help about `send`, type `cast send --help`.

To use `send` we need a signature and some arguments.

Please call the following in your terminal:

Note: Down below use the address you copy-pasted from your terminal, there's a chance it will be different than the one mine was deployed.

```solidity
cast send 0x5FbDB2315678afecb367f032d93F642f64180aa3 "store(uint256)" 1337 --rpc-url $RPC_URL --private-key $PRIVATE_KEY
```

### What did we just do?

Let's break it down:

   - `cast send` is the command we used to sign and publish our transaction;

   - `0x5FbDB2315678afecb367f032d93F642f64180aa3` or any other address is the target of our `cast send`, the contract we are interacting with;

   - `"store(uint256)"` is the signature of the function we are calling.

   - `1337` is the number we pass to the `store` function. As we can see in the function signature, we are expected to provide an `uint256` input. You can obviously provide any number you want, as long as it fits `uint256`.

   - you already know what `--rpc-url $RPC_URL --private-key $PRIVATE_KEY` are. The place where we send and the private key we use to sign.
   
### Reading information from the blockchain

`cast` conveniently provides a way to read information stored on the blockchain. Type `cast call --help` in your terminal to find out more. It works similarly to `send`, where you have to provide a signature and some arguments. The difference is you are only peering into the storage, not modifying it.

Call the following command in your terminal:

```solidity
cast call 0x5FbDB2315678afecb367f032d93F642f64180aa3 "retrieve()"
```

We receive back the following:

```solidity
0x0000000000000000000000000000000000000000000000000000000000000539
```

This represents a hex value. In the previous lessons, we learned how to convert this to a normal number.

Type the following command in your terminal:

```solidity
cast --to-base 0x0000000000000000000000000000000000000000000000000000000000000539 dec
```

And surprise, surprise, 1337 came back.

I recommend you play around and send multiple transactions with different numbers and then read them from the blockchain.

Awesome! We've learned something very valuable. You are going to use this more times than you can count.

Up next: Deploying a smart contract on Sepolia

# Deploying a smart contract on testnet (Sepolia) or Live Network with Foundry and Alchemy

Hi, everyone! Are you curious about what your contract would look like on a testnet or a live network? If so, buckle up because this blog post will cover exactly that! We'll walk through the process of updating our Environment Variable (.env) file for an actual testnet.

Clearly, we need an actual testnet for a real network. But our trusty MetaMask has built-in Infura connections that are incompatible. Why? Because they're tailored specifically for MetaMask. Hence, we need our own Remote Procedure Call (RPC) URL.

## Creating our Own RPC URL for a Testnet

_To create one, we could run our own blockchain node, but let's be honest — many folks prefer avoiding that route. Instead, we utilize Node as a Service (NaaS) applications to expedite the process._

One promising option is using Alchemy - a free NaaS platform that we can send the transactions to. This procedure resides within the Deploying to Testnet or Mainnet section in the full course repo of the Foundry.

![alchemy](../images.alchemy.png)

To access the Alchemy platform, we simply click on the aforementioned function. On the platform, we sign up (I used Google sign-in for this demo).

Our next step is creating a new app in the Alchemy user interface. I named mine Sepolia Testing and kept the description the same, given that our chain will be an Ethereum one based on Ethiopia.

We can bypass advanced features for now and finalize our app. Now we have the app details needed for our node, including frequency of calls and other details. We also have a new https endpoint by clicking view key, which functions exactly the same way as our ganache or MetaMask endpoint.

## Altering our Private Key

Next, let's do something about our private keys. Our ganache private key will no longer cut it — it has neither real money nor any testnet ETH in it.

Our solution is to use one of our MetaMask private keys. To do this, we switch back to Sepolia in our MetaMask, choose an account with money in it, click on account details, and export the private key. Remember, never share your real private key!

Upon confirmation with your password, copy the private key and omit the line in the env file — hashtag or pound sign denoting comments.

## Executing the Transaction

With our Sepolia RPC URL and private key from MetaMask, executing a transaction now becomes tremendously easier.

```bash
source .env
forge script script/deploySimpleStorage.s.sol --rpc-url=$Sepolia_RPC_URL --private-key=$PRIVATE_KEY --broadcast
```

This command deploys our contract to the testnet, and we can monitor the transaction on our Alchemy dashboard.

We soon find that our contract, Simple Storage, has been deployed on the Sepolia chain. We can grab our transaction hash and input it into Sepolia etherscan IO to confirm the successful transaction.

After we refresh our Alchemy dashboard, we'll verify the requests sent and track the ETH send raw transaction that transmitted our transaction to the blockchain.

So, this is how we deploy our contract on a real testnet leveraging Foundry and Alchemy!

Our next step will explore adding real-world components to the mix. Stay tuned!

# Quiz 24

**1. What essential configuration detail specifies the network address required for tools and applications to communicate with a running blockchain node?**
* *a) Chain ID*
* *b) Mnemonic Phrase*
* *c) Private Key*
* *d) RPC URL*

<details>
  <summary>Click to reveal answer</summary>
  <p>d) RPC URL.</p>
</details>


**2. Which component functions as an integrated, local blockchain node designed for development within Foundry?**
* *a) MetaMask*
* *b) Remix IDE*
* *c) Sepolia Testnet*
* *d) Anvil*

<details>
  <summary>Click to reveal answer</summary>
  <p>d) Anvil</p>
</details>

**3. In the context of blockchain systems, what level of control does a private key typically grant?**
* *a) The ability to propose network upgrades.*
* *b) Complete control over the associated account and its assets.*
* *c) Permission to view other users' private keys.*
* *d) Read-only access to the account's transaction history.*

<details>
  <summary>Click to reveal answer</summary>
  <p>b) Complete control over the associated account and its assets.</p>
</details>

**4. What cryptographic element is essential for verifying that a transaction was authorized by the owner of the sending account?**
* *a) A digital signature generated using the sender's private key.*
* *b) A timestamp indicating when the transaction was created.*
* *c) The public key of the transaction's recipient.*
* *d) A confirmation hash provided by a network validator.*

<details>
  <summary>Click to reveal answer</summary>
  <p>a) A digital signature generated using the sender's private key.</p>
</details>

**5. Which component of a transaction's data structure serves as a counter to ensure sequential processing and prevent duplication from a specific sender?**
* *a) Data Payload*
* *b) Value*
* *c) Nonce*
* *d) Gas Limit*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) Nonce</p>
</details>

**6. When managing code in version control systems, like Git, what standard practice helps prevent the accidental exposure of files containing sensitive information?**
* *a) Adding comments within the sensitive files warning about their content*
* *b) Using complex file names for sensitive files*
* *c) Listing the sensitive files or patterns in a dedicated ignore file (e.g., `.gitignore`)*
* *d) Encrypting the entire code repository*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) Listing the sensitive files or patterns in a dedicated ignore file (e.g., `.gitignore`)</p>
</details>

**7. If a private key controlling valuable digital assets is inadvertently exposed, what is the most critical and immediate action required?**
* *a) Monitor the account closely for unauthorized transactions*
* *b) Change the password associated with the service where the key was stored*
* *c) Transfer all assets controlled by the compromised key to a new, secure account/key immediately*
* *d) Delete the file or message where the key was exposed*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) Transfer all assets controlled by the compromised key to a new, secure account/key immediately</p>
</details>

**8. Why is passing secret keys or passwords directly as command-line arguments generally considered insecure?**
* *a) Command-line arguments have strict character limits.*
* *b) The command and its arguments may be logged in the shell's history file.*
* *c) It requires elevated system privileges which are hard to manage.*
* *d) Operating systems typically broadcast command-line arguments over the network.*

<details>
  <summary>Click to reveal answer</summary>
  <p>b) The command and its arguments may be logged in the shell's history file.</p>
</details>

**9. When interacting with a deployed smart contract, which type of operation requires a private key signature and consumes network resources (gas)?**
* *a) An operation that modifies the contract's stored data.*
* *b) An operation querying the current block number from the network node.*
* *c) An operation that reads data using a 'view' function.*
* *d) An operation that performs a calculation using a 'pure' function without accessing storage.*

<details>
  <summary>Click to reveal answer</summary>
  <p>a) An operation that modifies the contract's stored data.</p>
</details>

**10. If interacting with a smart contract returns a value encoded as a long hexadecimal string (e.g., `0x000...01A4`), what step is often needed to interpret this value?**
* *a) Verifying the sender's address on a block explorer.*
* *b) Converting the hexadecimal string to a different numerical base, such as decimal.*
* *c) Checking the transaction's gas usage.*
* *d) Submitting a new transaction to decode the value on-chain.*

<details>
  <summary>Click to reveal answer</summary>
  <p>b) Converting the hexadecimal string to a different numerical base, such as decimal.</p>
</details>

**11. What is a primary advantage of deploying a smart contract to a public testnet compared to exclusively using a local development environment?**
* *a) It guarantees the security of the smart contract code.*
* *b) It completely eliminates the need for gas fees.*
* *c) It allows testing under conditions that more closely mimic a live public blockchain.*
* *d) It provides faster transaction confirmation times than local networks.*

<details>
  <summary>Click to reveal answer</summary>
  <p>c) It allows testing under conditions that more closely mimic a live public blockchain.</p>
</details>

**12. After executing a deployment command for a smart contract to a public network, what is a common method to verify that the contract was successfully created on the blockchain?**
* *a) Checking the balance of the deployer account to see if it decreased slightly.*
* *b) Relying solely on the console output of the deployment tool without checking external sources.*
* *c) Re-running the deployment script multiple times until it shows success.*
* *d) Using a block explorer (like Etherscan) to check the status of the deployment transaction hash and look for the contract creation event.*

<details>
  <summary>Click to reveal answer</summary>
  <p>d) Using a block explorer (like Etherscan) to check the status of the deployment transaction hash and look for the contract creation event.</p>
</details>

# Verify a smart contract on Etherscan (Manually)

Soooo ... we just deployed our smart contract on Sepolia, let's check it out!

We go [here](https://sepolia.etherscan.io/address/0x1093560Fe9029c4fB9044AbF2fC94288970D98Db#code) click on Contract and find this:

![etherscan](../images/etherscan.png)

This bytecode looks horrendous. We need to do something to improve the readability (which currently is non-existent).

Etherscan is prompting us to do something about it via the message: `Are you the contract creator? Verify and Publish your contract source code today!`

So, let's click on `Verify and Publish`.

The address of the Contract comes prepopulated, if not please paste it from your terminal.

Select `Solidity(Single file)` because we are using solidity and we have only one file.

Select your Compiler Version. My contract used solidity 0.8.19.

The license type we used is MIT.

On the next page, paste your Solidity Contract. Select `Yes` in `Optimization`, and leave everything else as is.

Finish up the `verify` process. If you get this message:

```solidity
Successfully generated Bytecode and ABI for Contract Address [0x1093560Fe9029c4fB9044AbF2fC94288970D98Db]
```

you did it right!

Now you have access to the `Read Contract` and `Write Contract`. This lets you interact directly with your contract through etherscan.

Congratz! You just learned how to verify a smart contract on etherscan, the manual way. This is not the ideal way, in the future, we will teach you how to verify them programmatically.

# Cleaning up the project
We've covered a lot of ground in this project. We learned how to write our first Solidity contract, how to deploy it to a test network, and how to interact with it using Forge. Before we move on to more complex projects, let's take a moment to clean things up and make sure our project is well-organized.

## Formatting

One important aspect of any project is consistency in formatting. We've been using VS Code's auto-formatter to help us with this, but it's important to make sure that anyone else working on the project is following the same formatting rules.

Forge has a built-in format command that we can use to ensure consistent formatting across the project. We can run this command in our terminal with:

```solidity
forge fmt
```

This command will automatically format all our Solidity files according to Forge's default style.

## README.md

Another important file to include in any project is a `README.md` file. This file serves as a guide for anyone who wants to learn about your project, how to use it, or how to contribute to it.

The `README.md` file is written in Markdown, which is a lightweight markup language that's easy to read and write.

Here's an example of what you might include in your `README.md` file:

```markdown
# SimpleStorage
​
This is a simple Solidity contract that stores a single uint256 value.
​
## Getting Started
​
1. Clone this repository.
2. Install Forge using the instructions found at [https://github.com/foundry-rs/foundry](https://github.com/foundry-rs/foundry).
3. Run the following command to compile the contract:
​
```bash
forge build
```
​
4. Run the following command to deploy the contract to a test network:
​
```bash
forge create
```
​
5. Interact with the contract using Forge's interactive console.
​
```bash
forge console
```
​
## Contributing
​
We welcome contributions to this project. If you're interested in contributing, please open an issue or submit a pull request. 

We can preview our `README.md` file in VS Code by going to the `View` menu and selecting `Open Preview to the Side`. This will open a new window showing what the `README.md` file will look like when it's rendered on GitHub.
​
### Using AI for Markdown Formatting
​
If you find that formatting Markdown is a bit tedious, you can use an AI tool like ChatGPT to help you out. Just copy and paste the text you want to format into ChatGPT and ask it to format it in Markdown. It will do a pretty good job of converting your plain text into Markdown, and you can then review and edit it as needed.
​```
***

# Foundry Zksync

In this lesson, we'll explore Layer 2 deployment on ZKsync, which involves a different compilation method compared to Ethereum. This difference arises because ZKsync uses unique opcodes. While Solidity code behaves similarly on both platforms, the low-level outputs generated by Foundry in the /out folder will not be entirely compatible with the ZKsync VM.

To get started with ZKsync, we will follow these three steps:

 1. 🛠️ Install foundry-zksync

 2. 🧑‍💻 Compile the Solidity contract with the --zksync flag

 3. 🔄🏠 Reinstall the original Vanilla Foundry

>    👀❗IMPORTANT\
>   Installing `foundry-zksync` will override any existing Foundry binaries, such as `forge` and `cast`.

The GitHub resources for this course contain a link to the Foundry ZKsync repository. `foundry-zksync` is a fork of Foundry tailored for the ZKsync environment. The [repository](https://foundry-book.zksync.io/getting-started/installation) includes quick install instructions to help you set up the tool.

   - First, clone the Foundry ZKsync repository in a different directory from your Foundry project. Use the `git clone` command to clone the repository locally on your computer.

   - Once cloned, navigate to the created Foundry ZKsync directory and run the installation command:
   
```solidity
    ./install-foundry-zksync
```
   - This command requires a Unix-like environment, such as WSL on Windows, or a Mac or Linux system. After running the command, verify the installation by checking the version with `forge --version`. A different version number will indicate the successful installation of Foundry ZKsync.

    To keep your environment flexible, you can switch to Foundry ZKsync by running `foundryup-zksync`. After using it, it's recommended to switch back to Vanilla Foundry by running the `foundryup` command. This removes ZKsync-specific flags and settings, allowing you to easily toggle between Foundry ZKsync and Vanilla Foundry as needed.


## Compiling Foundry Zksync

> Previously, when we ran the `forge build` command, it generated an `/out` folder in the root project directory. This folder contains all the compilation details related the Ethereum Virtual Machine (EVM) and Vanilla Foundry. To compile for the ZKsync chain instead, we use the command `forge build --zksync`. This command creates a new folder in our project root called `/zkout`, and contains all the compiled code compatible to the ZKsync Era VM.

If we need to revert to vanilla Foundry for deployment on the EVM, we simply run the command `foundryup` and then use `forge build`, which builds a standard Foundry project. Unless otherwise specified, we should continue using this method.
